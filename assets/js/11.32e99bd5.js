(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{516:function(v,_,t){"use strict";t.r(_);var r=t(5),e=Object(r.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"http协议简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http协议简介"}},[v._v("#")]),v._v(" HTTP协议简介")]),v._v(" "),t("p",[v._v("​\t《图解HTTP》")]),v._v(" "),t("blockquote",[t("p",[v._v("Web（万维网）使用一种名为HTTP（HyperText Transfer Protocol，超文本传输协议）的协议作为规范，完成从客户端到服务器等一系列运作流程。而协议是指规则的约定。可以说，Web是建立在HTTP协议上通信的。")])]),v._v(" "),t("h2",{attrs:{id:"tcp-ip协议族"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp-ip协议族"}},[v._v("#")]),v._v(" TCP/IP协议族")]),v._v(" "),t("blockquote",[t("p",[v._v("计算机各网络设备之间进行通信时，双方必须基于相同的方法，如通信时先由哪一边的目标先发起通信、通信时使用哪种语言、通信如何结束等，都需要事先确定。不同的硬件、操作系统之间的通信都需要一种规则来进行管理和约束，我们就把这种规则称为"),t("strong",[v._v("协议")]),v._v("。")]),v._v(" "),t("p",[v._v("协议不仅可以管理和规定通信的方式，从电缆的规格到IP地址的选定方法，再到web端的页面显示需要处理的步骤等都是协议来进行约束和控制的。而"),t("strong",[v._v("TCP/IP协议族就负责把这些互联网相关的协议集合起来的总体")]),v._v("，但也有说法说TCP/IP就只是指TCP和IP协议")]),v._v(" "),t("p",[v._v("TCP/IP协议族里最重要的一点就是分层思想的运用，按层次分为以下四层："),t("strong",[v._v("应用层")]),v._v("、"),t("strong",[v._v("传输层")]),v._v("、"),t("strong",[v._v("网络层")]),v._v("和"),t("strong",[v._v("数据链路层")]),v._v(")。"),t("strong",[v._v("分层思想")]),v._v("就是把通信的这整个过程划分成几个部分，如果不采用分层的思想设计，把互联网按照一个协议来进行统筹，但我们进行某个地方的改动时，就必须把所有部分整体替换掉。而如果采用了分层的思想，那么我们只需要把变动的层修改或者替换掉，而每个层之间的接口规划好后，每个层的内部设计就相互独立，互不影响了。")]),v._v(" "),t("p",[v._v("参考"),t("a",{attrs:{href:"https://www.zhihu.com/question/307883600/answer/2250473781",target:"_blank",rel:"noopener noreferrer"}},[v._v("知乎"),t("OutboundLink")],1)])]),v._v(" "),t("p",[v._v("为了更好的理解HTTP协议，我们必须先了解一下TCP/IP协议族。TCP/IP协议族是Internet最基本的协议，HTTP协议是它们的一个子集。"),t("strong",[v._v("TCP/IP协议族按层次分为以下四层")]),v._v(":")]),v._v(" "),t("h3",{attrs:{id:"应用层"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#应用层"}},[v._v("#")]),v._v(" "),t("strong",[v._v("应用层")]),v._v("：")]),v._v(" "),t("ul",[t("li",[t("p",[t("strong",[v._v("应用层主要包括")]),v._v("："),t("strong",[v._v("应用程序")]),v._v("、"),t("strong",[v._v("服务")]),v._v("和"),t("strong",[v._v("实现服务的协议")]),v._v("，应用程序为我们提供创建消息的方法，服务负责创建与网络交互的接口，协议负责提供进行数据处理的规则和格式。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("应用层的主要功能："),t("strong",[v._v("通过应用程序，将用户")]),v._v("操作")]),v._v("转换成为"),t("strong",[v._v("服务")]),v._v("，并对特定的服务匹配一个"),t("strong",[v._v("相应的服务协议")]),v._v("来发送给"),t("strong",[v._v("传输层")])])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("简单直白点说")]),v._v("：应用层的东西偏向于向用户直接接触，与用户直接交互，为用户提供直接服务，然后把用户想要发送的数据打包给传输层来进行传输。")])]),v._v(" "),t("li",[t("p",[v._v("应用层是直接与用户进行交互的层，它决定了向用户提供的应用服务和通信的活动。应用层包含所有的高层协议，包括：虚拟终端协议（TELNET）、文件传输协议（"),t("strong",[v._v("FTP")]),v._v("）、电子邮件传输协议（SMTP）、域名服务（"),t("strong",[v._v("DNS")]),v._v("）、网上新闻传输协议（NNTP）和超文本传送协议（"),t("strong",[v._v("HTTP")]),v._v("）等。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("浅谈DNS解析过程")])]),v._v(" "),t("blockquote",[t("ol",[t("li",[v._v("浏览器根据地址去本身缓存中查找dns解析记录，如果有，则直接返回IP地址，否则浏览器会查找操作系统中（hosts文件）是否有该域名的dns解析记录，如果有则返回。")]),v._v(" "),t("li",[v._v("如果浏览器缓存和操作系统hosts中均无该域名的dns解析记录，或者已经过期，此时就会向域名服务器发起请求来解析这个域名。")]),v._v(" "),t("li",[v._v("请求会先到LDNS（本地域名服务器），让它来尝试解析这个域名，如果LDNS也解析不了，则直接到根域名解析器请求解析")]),v._v(" "),t("li",[v._v("根域名服务器给LDNS返回一个所查询余的主域名服务器（gTLDServer）地址。")]),v._v(" "),t("li",[v._v("此时LDNS再向上一步返回的gTLD服务器发起解析请求。")]),v._v(" "),t("li",[v._v("gTLD服务器接收到解析请求后查找并返回此域名对应的Name Server域名服务器的地址，这个Name Server通常就是你注册的域名服务器（比如阿里dns、腾讯dns等）")]),v._v(" "),t("li",[v._v("Name Server域名服务器会查询存储的域名和IP的映射关系表，正常情况下都根据域名得到目标IP记录，连同一个TTL值返回给DNS Server域名服务器")]),v._v(" "),t("li",[v._v("返回该域名对应的IP和TTL值，Local DNS Server会缓存这个域名和IP的对应关系，缓存的时间有TTL值控制。")]),v._v(" "),t("li",[v._v("把解析的结果返回给用户，用户根据TTL值缓存在本地系统缓存中，域名解析过程结束。")])])])])]),v._v(" "),t("h3",{attrs:{id:"传输层"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#传输层"}},[v._v("#")]),v._v(" 传输层：")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("使源端和目的端机器上的对等实体可以进行"),t("strong",[v._v("会话")]),v._v("。在这一层定义了两个"),t("strong",[v._v("端到端")]),v._v("（也就是进程之间）的协议：传输控制协议（"),t("strong",[v._v("TCP")]),v._v("）和用户数据报协议（"),t("strong",[v._v("UDP")]),v._v("）")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("传输层的主要职责")]),v._v("：在"),t("strong",[v._v("源")]),v._v("和"),t("strong",[v._v("目标主机")]),v._v("的应用程序之间利用"),t("strong",[v._v("端口号")]),v._v("来跟踪独立的通信；将"),t("strong",[v._v("应用层")]),v._v("发送来的数据分段并进行管理；将这些数据片段重组为完整的"),t("strong",[v._v("应用数据流")]),v._v("；在终端用户之间执行流量控制；会执行差错恢复，即错误重传； 建立和开始一个会话等。")])]),v._v(" "),t("li",[t("p",[v._v("使源端和目的端机器上的"),t("strong",[v._v("对等")]),v._v("实体可以进行会话。在这一层定义了两个"),t("strong",[v._v("端到端")]),v._v("的协议：传输控制协议（"),t("strong",[v._v("TCP")]),v._v("）和用户数据报协议（"),t("strong",[v._v("UDP")]),v._v("）。TCP是面向连接的协议，它提供可靠的报文传输和对上层应用的连接服务。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("有点难理解：主要就是数据包到达目标计算机后，发送到响应进程，应该就是进程与进程之间的通信，这种通信是建立在点到点也就主机与主机的的基础上，这就涉及网络层了，通信的真正端点并不是主机而是主机中的进程。")])])]),v._v(" "),t("li",[t("p",[v._v("在传输层有两个性质不同的协议：TCP(Transmission Control Protocol，传输控制协议)和UDP(User Data Protocol，用户数据报协议)。")]),v._v(" "),t("p",[t("strong",[v._v("TCP协议是全双工的")]),v._v("，允许双方进程在任何时候都可以通信，就好像我们打电话一样，说话的同时也能听见。并且TCP"),t("strong",[v._v("最大的特点就是面向连接的传输层协议")]),v._v("，应用程序在使用TCP协议之前，"),t("strong",[v._v("必须先建立TCP连接")]),v._v("，数据传输完毕后，"),t("strong",[v._v("必须释放TCP连接")]),v._v("。就像打电话，先拨号才能建立连接，通话结束要挂断电话才能释放连接。TCP协议在建立连接和断开连接时有"),t("strong",[v._v("三次握手")]),v._v("和"),t("strong",[v._v("四次挥手")]),v._v("，因此在传输的过程中更稳定可靠但同时就没有UDP那么高效了。")]),v._v(" "),t("p",[t("strong",[v._v("TCP共有6个标志位")]),v._v("，分别是：")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("SYN(synchronous),建立联机。")])]),v._v(" "),t("li",[t("p",[v._v("ACK(acknowledgement),确认。")])]),v._v(" "),t("li",[t("p",[v._v("PSH(push),传输。")])]),v._v(" "),t("li",[t("p",[v._v("FIN(finish),结束。")])]),v._v(" "),t("li",[t("p",[v._v("RST(reset),重置。")])]),v._v(" "),t("li",[t("p",[v._v("URG(urgent),紧急。")]),v._v(" "),t("p",[t("strong",[v._v("URG")]),v._v('：紧急标志。紧急标志为"1"表明该位有效。')]),v._v(" "),t("p",[t("strong",[v._v("ACK")]),v._v("：确认标志。表明确认编号栏有效。大多数情况下该标志位是置位的。TCP报头内的确认编号栏内包含的确认编号（w+1）为下一个预期的序列编号，同时提示远端系统已经成功接收所有数据。")]),v._v(" "),t("p",[t("strong",[v._v("PSH")]),v._v("：推标志。该标志置位时，接收端不将该数据进行队列处理，而是尽可能快地将数据转由应用处理。在处理Telnet或rlogin等交互模式的连接时，该标志总是置位的。")]),v._v(" "),t("p",[t("strong",[v._v("RST")]),v._v("：复位标志。用于复位相应的TCP连接。")]),v._v(" "),t("p",[t("strong",[v._v("SYN")]),v._v("：同步标志。表明同步序列编号栏有效。该标志仅在三次握手建立TCP连接时有效。它提示TCP连接的服务端检查序列编号，该序列编号为TCP连接初始端（一般是客户端）的初始序列编号。在这里，可以把TCP序列编号看作是一个范围从0到4，294，967，295的32位计数器。通过TCP连接交换的数据中每一个字节都经过序列编号。在TCP报头中的序列编号栏包括了TCP分段中第一个字节的序列编号。")]),v._v(" "),t("p",[t("strong",[v._v("FIN")]),v._v("：结束标志。")])])])])]),v._v(" "),t("h4",{attrs:{id:"建立tcp连接-三次握手"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#建立tcp连接-三次握手"}},[v._v("#")]),v._v(" 建立TCP连接：三次握手")]),v._v(" "),t("ul",[t("li",[t("p",[t("strong",[v._v("第一次握手")]),v._v("：起初两端都处于 CLOSED 关闭状态，Client 将"),t("strong",[v._v("标志位")]),v._v(" SYN 置为 1，随机产生一个值 "),t("code",[v._v("seq = x")]),v._v("，并将该数据包发送给 Server，Client 进入 "),t("strong",[v._v("SYN-SENT")]),v._v(" 状态，等待 Server 确认。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("第二次握手")]),v._v("：Server 收到数据包后由"),t("strong",[v._v("标志位")]),v._v(" "),t("code",[v._v("SYN = 1")]),v._v(" 得知 Client 请求建立连接，"),t("strong",[v._v("Server 将标志位 SYN 和 ACK 都置为 1")]),v._v("，"),t("code",[v._v("ack = x + 1")]),v._v("，随机产生一个值 "),t("code",[v._v("seq = y")]),v._v("，并将该数据包发送给Client以确认连接请求，Server 进入 "),t("code",[v._v("SYN-RCVD")]),v._v(" 状态，"),t("strong",[v._v("此时操作系统为该 TCP 连接分配 TCP 缓存和变量")]),v._v("。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("第三次握手")]),v._v("：Client 收到确认后，检查 seq 是否为 "),t("code",[v._v("x + 1")]),v._v("，ACK 是否为 1，如果"),t("strong",[v._v("正确则将标志位 ACK 置为 1")]),v._v("，"),t("code",[v._v("ack = y + 1")]),v._v("，并且此时操作系统为该 "),t("strong",[v._v("TCP 连接分配 TCP 缓存和变量")]),v._v("，并将该数据包发送给 Server，Server 检查 ack 是否为 "),t("code",[v._v("y + 1")]),v._v("，ACK 是否为 1，如果正确则连接建立成功，Client 和 Server 进入 "),t("strong",[v._v("established")]),v._v(" 状态，完成三次握手，随后 Client 和 Server 就可以开始传输数据。")])])]),v._v(" "),t("img",{attrs:{src:"/assets/img/TCP三次握手.png"}}),v._v(" "),t("p",[v._v("A和B打电话\nA:歪，听得到吗？--SYN-SEND。。。。。\nB：嗯嗯，听得到，你能听得到我的回话吗？--SYN-RECIVED。。。。。\nA:啊，是你啊！我也听得到，让我们愉快的聊天吧；--"),t("strong",[v._v("established")]),v._v(" 。。。")]),v._v(" "),t("h4",{attrs:{id:"syn网络攻击"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#syn网络攻击"}},[v._v("#")]),v._v(" SYN网络攻击：")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以让之现行：")])]),v._v(" "),t("li",[t("div",{staticClass:"language-shell line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[v._v("#netstat -nap | grep SYN_RECV  ")]),v._v("\n")])]),v._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[v._v("1")]),t("br")])])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("检测：")])]),v._v(" "),t("p",[v._v("SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了。windows下打开cmd,输入命令：”netstat -n -p TCP“，查看是否有大量的”SYN_RECEIVED“状态。")])])]),v._v(" "),t("h4",{attrs:{id:"关闭tcp连接-四次挥手"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#关闭tcp连接-四次挥手"}},[v._v("#")]),v._v(" 关闭TCP连接：四次挥手")]),v._v(" "),t("ul",[t("li",[t("p",[t("strong",[v._v("第一次挥手")]),v._v("：Client 的应用进程先向其 TCP 发出连接释放报文段（"),t("code",[v._v("FIN = 1")]),v._v("，序号 "),t("code",[v._v("seq = u")]),v._v("），并停止再发送数据，主动关闭 TCP 连接，进入 FIN-WAIT-1（终止等待1）状态，等待 Server 的确认。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("第二次挥手")]),v._v("：Server 收到连接释放报文段后即发出确认报文段，（"),t("code",[v._v("ACK = 1")]),v._v("，确认号 "),t("code",[v._v("ack = u + 1")]),v._v("，序号 "),t("code",[v._v("seq = v")]),v._v("），Server 进入 CLOSE-WAIT（关闭等待）状态，此时的 TCP 处于半关闭状态，Client 到 Server 的连接释放。")]),v._v(" "),t("blockquote",[t("p",[v._v("注：Client 收到 Server 的确认后，进入 FIN-WAIT-2（终止等待2）状态，等待 Server 发出的连接释放报文段。")])])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("第三次挥手")]),v._v("：Server 已经没有要向 Client 发出的数据了，Server 发出连接释放报文段（"),t("code",[v._v("FIN = 1")]),v._v("，"),t("code",[v._v("ACK = 1")]),v._v("，序号 "),t("code",[v._v("seq = w")]),v._v("，确认号 "),t("code",[v._v("ack = u + 1")]),v._v("），Server 进入 LAST-ACK（最后确认）状态，等待 Client 的确认。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("第四次挥手")]),v._v("：Client 收到 Server 的连接释放报文段后，对此发出确认报文段（"),t("code",[v._v("ACK = 1")]),v._v("，"),t("code",[v._v("seq = u + 1")]),v._v("，"),t("code",[v._v("ack = w + 1")]),v._v("），Client 进入 TIME-WAIT（时间等待）状态。此时 TCP 未释放掉，需要经过时间等待计时器设置的时间 2MSL 后，Client 才进入 CLOSED 状态。")])])]),v._v(" "),t("img",{attrs:{src:"/assets/img/TCP四次挥手.png"}}),v._v(" "),t("ul",[t("li",[t("p",[t("strong",[v._v("第一次挥手")]),v._v("：双方交流的差不多了，此时客户端也已经结尾了，接下来要断开通信连接，所以告诉服务端“我说完了（FIN）”，此时自身形成等待结束连接的状态。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("第二次挥手")]),v._v("：服务端知道客户端已经没话说了，服务端此时还有两句心里话要给客户端说，“我知道你说完了（ACK），我再给你说两句，&*……%￥”。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("第三次挥手")]),v._v("：此时客户端洗耳恭听继续处于等待结束的状态，服务器端也说完了，自身此时处于等待关闭连接的状态，并对告诉客户端，“我说完了，咱们断了吧（FIN）”。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("第四次挥手")]),v._v("：客户端收知道服务端也说完了，也要告诉服务端一声（ACK），因为连接和断开要双方都按下关闭操作才能断开，客户端同时又为自己定义一个定时器，因为不知道刚才说的这句话能不能准确到达服务端（网络不稳定或者其他因素引起的网络原因），默认时间定为两个通信的最大时间之和，超出这个时间就默认服务器端已经接收到了自己的确认信息，此时客户端就关闭自身连接，服务器端一旦接收到客户端发来的确定通知就立刻关闭服务器端的连接。")]),v._v(" "),t("p",[v._v("到此为止双方整个通信过程就此终结。这里要声明一下：断开链接不一定就是客户端，谁都可以先发起断开指令，另外客户端和服务端是没有固定标准的，谁先发起请求谁就是客户端。")])])]),v._v(" "),t("h4",{attrs:{id:"为什么建立连接是三次握手-而关闭连接却是四次挥手呢"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么建立连接是三次握手-而关闭连接却是四次挥手呢"}},[v._v("#")]),v._v(" 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？")]),v._v(" "),t("ul",[t("li",[v._v("这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。")])]),v._v(" "),t("h3",{attrs:{id:"网络层"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#网络层"}},[v._v("#")]),v._v(" "),t("strong",[v._v("网络层：")])]),v._v(" "),t("ul",[t("li",[t("p",[t("strong",[v._v("什么是网络")]),v._v("？我的理解就是英特网的脉络。包括英特网数据与他们之间的连接（欢迎大佬们指正与补充）")])]),v._v(" "),t("li",[t("p",[v._v("**网络是怎样连接的呢？**这是个很有意思的问题，欢迎大佬解答与补充。网络连接中必不可少的就是路由器")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("路由器是什么呢")]),v._v("？个人观点就是网络线路中的交警，用来指路的的设备，而路由器就是工作在网络层中的（欢迎大佬指正与补充）")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("网络层的作用是什么？")])]),v._v(" "),t("ul",[t("li",[t("p",[v._v("有人说是实现两个端系统之间的数据透明传送，具体功能包括寻址和路由选择、连接的建立、保持和终止等，简要概括来说就是**“路径选择、路由及逻辑寻址”**")])]),v._v(" "),t("li",[t("p",[v._v("负责相邻计算机之间的通信（"),t("strong",[v._v("IP协议")]),v._v("）。其功能包括三方面。\n一、处理来自传输层的分组发送请求，收到请求后，将分组装入IP数据报，填充报头，选择去往信宿机的路径，然后将数据报发往适当的链路层。")]),v._v(" "),t("p",[v._v("二、处理输入数据报：首先检查其合法性，然后进行寻径--假如该数据报已到达信宿机，则去掉报头，将剩下部分交给适当的传输协议；假如该数据报尚未到达信宿，则转发该数据报。")]),v._v(" "),t("p",[v._v("三、处理路径、流控、拥塞等问题。")])])])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("主要功能：")])]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("异构网络互联")]),v._v("：\n"),t("ul",[t("li",[v._v("所谓网络的互联是指将两个以上的计算机网络，通过一定的方法，用一种或者多种通信处理设备（中间设备）相互连接起来，以构成更大的网络系统。")])])]),v._v(" "),t("li",[t("strong",[v._v("路由与转发：")]),v._v(" "),t("ul",[t("li",[v._v("路由选择：指按照复杂的分布式算法。根据从各相邻路由器所得到的关于整个网络的拓扑情况，动态地改变所选择的路由")]),v._v(" "),t("li",[v._v("分组转发：指路由器根据转发表将用户的IP数据报从合适的端口转发出去")])])]),v._v(" "),t("li",[t("strong",[v._v("拥塞控制：")]),v._v(" "),t("ul",[t("li",[v._v("由于出现过量的分组而出现网络性能下降的现象成为拥塞")])])])])])]),v._v(" "),t("h3",{attrs:{id:"链路层"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#链路层"}},[v._v("#")]),v._v(" 链路层:")]),v._v(" "),t("ul",[t("li",[v._v("用来处理连接网络的"),t("strong",[v._v("硬件部分")]),v._v("，包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡，及光纤等"),t("strong",[v._v("物理可见部分")]),v._v("（"),t("strong",[v._v("还包括连接器等一切传输介质")]),v._v("）。硬件上的范畴均在链路层的作用范围内。")])]),v._v(" "),t("h2",{attrs:{id:"传输层与应用层和网络层的关系"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#传输层与应用层和网络层的关系"}},[v._v("#")]),v._v(" 传输层与应用层和网络层的关系！！！：")]),v._v(" "),t("ul",[t("li",[v._v("传输层为应用层上的每一个协议标识了一个端口号，也就是传输层通过不同的端口号来区分不同的应用层协议，\n"),t("ol",[t("li",[v._v("HTTP协议默认使用了TCP的80端口号")]),v._v(" "),t("li",[v._v("FTP协议默认使用TCP的21端口号")]),v._v(" "),t("li",[v._v("TELNET协议默认使用了TCP的23端口号")]),v._v(" "),t("li",[v._v("SMTP协议默认使用了TCP的25端口号")]),v._v(" "),t("li",[v._v("DNS协议默认使用了UDP的53端口号")]),v._v(" "),t("li",[v._v("RIP协议默认使用了UDP的520端口号")]),v._v(" "),t("li",[v._v("DHCP协议默认使用了UDP的67端口号")])])]),v._v(" "),t("li",[v._v("IP地址是用来定位网络上的某一台服务器，而端口号是用来定位服务器上的某一个服务")]),v._v(" "),t("li",[t("strong",[v._v("应用层")]),v._v("负责与用户进行交互，"),t("strong",[v._v("关注的是传什么数据")]),v._v("，这些服务器都是无法识别的，需要传输层特定的协议来。")]),v._v(" "),t("li",[t("strong",[v._v("传输层负责怎么传")]),v._v("，传输层会将应用层的数据，解析成计算机能识别的字节数据，运输层提供进程之间的逻辑通信，“逻辑通信”就是：从应用层的角度来看，只要把应用层报文交给下面的传输层，传输层就可以把这报文传送到对方的运输层")]),v._v(" "),t("li",[t("strong",[v._v("网络层")]),v._v("提供的就是主机之间的逻辑通信")])]),v._v(" "),t("h2",{attrs:{id:"http协议与tcp协议的关系"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http协议与tcp协议的关系"}},[v._v("#")]),v._v(" HTTP协议与TCP协议的关系：")]),v._v(" "),t("ul",[t("li",[v._v("如上面所说，TCP协议为HTTP协议标识了一个端口号，所以HTTP协议是基于TCP协议的")])]),v._v(" "),t("h2",{attrs:{id:"正题来了"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#正题来了"}},[v._v("#")]),v._v(" 正题来了：")]),v._v(" "),t("h3",{attrs:{id:"http协议概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http协议概述"}},[v._v("#")]),v._v(" HTTP协议概述：")]),v._v(" "),t("ul",[t("li",[v._v("HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，"),t("strong",[v._v("请求报文包含")]),v._v("请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，"),t("strong",[v._v("响应的内容")]),v._v("包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。")])]),v._v(" "),t("h3",{attrs:{id:"http协议主要特点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http协议主要特点"}},[v._v("#")]),v._v(" HTTP协议主要特点：")]),v._v(" "),t("p",[v._v("1、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。")]),v._v(" "),t("p",[v._v("2、灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。")]),v._v(" "),t("p",[v._v("3.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。")]),v._v(" "),t("p",[v._v("4.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。")]),v._v(" "),t("ul",[t("li",[v._v("随着Web应用程序的出现，直接在客户端存储用户信息的需求也随之出现。这背后的想法是合理的：与特定用户相关的的信息应该保存在用户的机器上。无论是登录信息、个人偏好、还是其他数据。Web应用程序提供者都需要有办法把它们保存在客户端。")]),v._v(" "),t("li",[v._v("但是HTTP是不保存状态的协议，即无状态协议，协议本身对于请求或响应之间的通信状态不进行保存，因此连接双方不能知晓对方当前的身份和状态。所以客户端存储的第一个解决方案"),t("code",[v._v("HTTP cookie")]),v._v("规范出现了。")]),v._v(" "),t("li",[v._v("该规范要求服务器在响应HTTP请求时，通过发送Set-Cookie的HTTP头部包含会话信息，与此同时，由于cookie只能通过请求头来通信的限制，后面的sessionStorage、localStorage等新的客户端存储方案也出现了")])]),v._v(" "),t("p",[v._v("5、支持B/S及C/S模式。")]),v._v(" "),t("h3",{attrs:{id:"http之url"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http之url"}},[v._v("#")]),v._v(" HTTP之URL:")]),v._v(" "),t("p",[v._v("HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息")]),v._v(" "),t("p",[v._v("URL,全称是UniformResourceLocator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。")]),v._v(" "),t("p",[v._v("一个完整的URL包括以下几部分：")]),v._v(" "),t("ol",[t("li",[v._v('协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在"HTTP"后面的“//”为分隔符')]),v._v(" "),t("li",[v._v("域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用")]),v._v(" "),t("li",[v._v("端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口")]),v._v(" "),t("li",[v._v("虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”")]),v._v(" "),t("li",[v._v("文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名")]),v._v(" "),t("li",[v._v("锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分")]),v._v(" "),t("li",[v._v("参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&ID=24618&page=1”。参数可以允许有多个参数，参数与参数之间用“&”作为分隔符。")])]),v._v(" "),t("h3",{attrs:{id:"http工作原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http工作原理"}},[v._v("#")]),v._v(" HTTP工作原理：")]),v._v(" "),t("p",[v._v("HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。")]),v._v(" "),t("h3",{attrs:{id:"htpp状态码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#htpp状态码"}},[v._v("#")]),v._v(" HTPP状态码：")]),v._v(" "),t("table",[t("thead",[t("tr",[t("th",[v._v("2XX")]),v._v(" "),t("th",[v._v("成功（这系列表明请求被正常处理了）")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[v._v("200")]),v._v(" "),t("td",[v._v("OK，表示从客户端发来的请求在服务器端被正确处理")])]),v._v(" "),t("tr",[t("td",[v._v("204")]),v._v(" "),t("td",[v._v("No content，表示请求成功，但响应报文不含实体的主体部分")])]),v._v(" "),t("tr",[t("td",[v._v("206")]),v._v(" "),t("td",[v._v("Partial Content，进行范围请求成功")])])])]),v._v(" "),t("table",[t("thead",[t("tr",[t("th",[v._v("3XX")]),v._v(" "),t("th",[v._v("重定向（表明浏览器要执行特殊处理）")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[v._v("301")]),v._v(" "),t("td",[v._v("moved permanently，永久性重定向，表示资源已被分配了新的 URL")])]),v._v(" "),t("tr",[t("td",[v._v("302")]),v._v(" "),t("td",[v._v("found，临时性重定向，表示资源临时被分配了新的 URL")])]),v._v(" "),t("tr",[t("td",[v._v("303")]),v._v(" "),t("td",[v._v("see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源（对于301/302/303响应，几乎所有浏览器都会删除报文主体并自动用GET重新请求）")])]),v._v(" "),t("tr",[t("td",[v._v("304")]),v._v(" "),t("td",[v._v("not modified，表示服务器允许访问资源，但请求未满足条件的情况（与重定向无关）")])]),v._v(" "),t("tr",[t("td",[v._v("307")]),v._v(" "),t("td",[v._v("temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求")])])])]),v._v(" "),t("table",[t("thead",[t("tr",[t("th",[v._v("4XX")]),v._v(" "),t("th",[v._v("客户端错误")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[v._v("400")]),v._v(" "),t("td",[v._v("bad request，请求报文存在语法错误")])]),v._v(" "),t("tr",[t("td",[v._v("401")]),v._v(" "),t("td",[v._v("unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息")])]),v._v(" "),t("tr",[t("td",[v._v("403")]),v._v(" "),t("td",[v._v("forbidden，表示对请求资源的访问被服务器拒绝，可在实体主体部分返回原因描述")])]),v._v(" "),t("tr",[t("td",[v._v("404")]),v._v(" "),t("td",[v._v("not found，表示在服务器上没有找到请求的资源")])])])]),v._v(" "),t("table",[t("thead",[t("tr",[t("th",[v._v("5XX")]),v._v(" "),t("th",[v._v("服务器错误")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[v._v("500")]),v._v(" "),t("td",[v._v("internal sever error，表示服务器端在执行请求时发生了错误")])]),v._v(" "),t("tr",[t("td",[v._v("501")]),v._v(" "),t("td",[v._v("Not Implemented，表示服务器不支持当前请求所需要的某个功能")])]),v._v(" "),t("tr",[t("td",[v._v("503")]),v._v(" "),t("td",[v._v("service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求")])])])]),v._v(" "),t("hr"),v._v(" "),t("h2",{attrs:{id:"从用户输入url-到浏览器呈现给用户页面-经历了什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#从用户输入url-到浏览器呈现给用户页面-经历了什么"}},[v._v("#")]),v._v(" 从用户输入URL，到浏览器呈现给用户页面，经历了什么")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("用户输入URL，浏览器获取到URL")])]),v._v(" "),t("li",[t("p",[v._v("浏览器(应用层)进行DNS解析（如果输入的是IP地址，此步骤省略）")])]),v._v(" "),t("li",[t("p",[v._v("根据解析出的IP地址+端口，浏览器（应用层）发起HTTP请求，请求中携带（请求头header（也可细分为请求行和请求头）、请求体body），")]),v._v(" "),t("blockquote",[t("p",[t("strong",[v._v("header包含：")])]),v._v(" "),t("ol",[t("li",[v._v("请求的方法（get、post、put..）")]),v._v(" "),t("li",[v._v("协议（http、https、ftp、sftp…）")]),v._v(" "),t("li",[v._v("目标url（具体的请求路径已经文件名）")]),v._v(" "),t("li",[v._v("一些必要信息（缓存、cookie之类）")])]),v._v(" "),t("p",[t("strong",[v._v("body包含：")])]),v._v(" "),t("ol",[t("li",[v._v("请求的内容")])])])]),v._v(" "),t("li",[t("p",[v._v("请求到达传输层，tcp协议为传输报文提供可靠的字节流传输服务，它通过三次握手等手段来保证传输过程中的安全可靠。通过对大块数据的分割成一个个报文段的方式提供给大量数据的便携传输。")])]),v._v(" "),t("li",[t("p",[v._v("到网络层， 网络层通过ARP寻址得到接收方的Mac地址，IP协议把在传输层被分割成一个个数据包传送接收方。")])]),v._v(" "),t("li",[t("p",[v._v("数据到达数据链路层，请求阶段完成")])]),v._v(" "),t("li",[t("p",[v._v("接收方在数据链路层收到数据包之后，层层传递到应用层，接收方应用程序就获得到请求报文。")])]),v._v(" "),t("li",[t("p",[v._v("接收方收到发送方的HTTP请求之后，进行请求文件资源（如HTML页面）的寻找并响应报文")])]),v._v(" "),t("li",[t("p",[v._v("发送方收到响应报文后，如果报文中的状态码表示请求成功，则接受返回的资源（如HTML文件），进行页面渲染。")])]),v._v(" "),t("li",[t("p",[v._v("页面的渲染：")]),v._v(" "),t("ul",[t("li",[v._v("浏览器通过 HTMLParser 根据深度遍历的原则把 HTML 解析成 DOM Tree。")]),v._v(" "),t("li",[v._v("浏览器通过 CSSParser 将 CSS 解析成 CSS Rule Tree（CSSOM Tree）。")]),v._v(" "),t("li",[v._v("浏览器将 JavaScript 通过 DOM API 或者 CSSOM API 将 JS 代码解析并应用到布局中，按要求呈现响应的结果。")]),v._v(" "),t("li",[v._v("根据 DOM 树和 CSSOM 树来构造 render Tree。")]),v._v(" "),t("li",[v._v("layout：重排（也可以叫回流），当 render tree 中任一节点的几何尺寸发生改变，render tree 就会重新布局，重新来计算所有节点在屏幕的位置。")]),v._v(" "),t("li",[v._v("repaint：重绘，当 render tree 中任一元素样式属性（几何尺寸没改变）发生改变时，render tree 都会重新画，比如字体颜色，背景等变化。")]),v._v(" "),t("li",[v._v("paint：遍历 render tree，并调动硬件图形 API 来绘制每个节点")])])])]),v._v(" "),t("img",{staticStyle:{zoom:"67%"},attrs:{src:"/assets/img/页面渲染过程.png"}}),v._v(" "),t("h4",{attrs:{id:"html解析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#html解析"}},[v._v("#")]),v._v(" HTML解析：")]),v._v(" "),t("p",[v._v("上面讲到，HTML解析是浏览器的HTML解析器把HTML解析成dom tree，而在解析过程，浏览器根据HTML文件的结构从上到下解析html，HTML元素是以深度优先的方式解析，而script、link、style等标签会使解析过程产生阻塞，阻塞的情况有：")]),v._v(" "),t("blockquote",[t("ol",[t("li",[v._v("外部样式会阻塞内部脚本的执行。")]),v._v(" "),t("li",[v._v("外部样式与外部脚本并行加载，但外部样式会阻塞外部脚本执行。")]),v._v(" "),t("li",[v._v("如果外部脚本带有async属性，则外部脚本的加载与执行不受外部样式影响")]),v._v(" "),t("li",[v._v("如果link标签是动态创建（js生成），不管有无async属性，都不会阻塞外部脚本的加载与执行。")])])]),v._v(" "),t("h4",{attrs:{id:"css解析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#css解析"}},[v._v("#")]),v._v(" css解析：")]),v._v(" "),t("blockquote",[t("p",[v._v("CSS Parser作用就是将很多个CSS文件中的样式合并解析出具有树形结构Style Rules，在对样式解析的过程中，默认CSS选择器是从右往左进行解析的")])]),v._v(" "),t("h4",{attrs:{id:"脚本执行"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#脚本执行"}},[v._v("#")]),v._v(" 脚本执行：")]),v._v(" "),t("blockquote",[t("p",[v._v("​\t浏览器解析HTML时，当遇到"),t("code",[v._v("<script>")]),v._v("标签就会立即解析脚本，同时阻塞解析文档直到脚本执行完毕（你可能问为什么要这样设计，明显啊，脚本的执行是改变css和dom，会造成render tree不停的重绘和重排的），而当"),t("code",[v._v("<script>")]),v._v("是引入外部js文件时，会阻塞到js文件下载完成并且执行完成为止（除非加了defer或者async属性）。脚本在解析过程中将对dom或css的操作解析出来加入到DOM Tree和cssom中")])]),v._v(" "),t("h4",{attrs:{id:"性能优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#性能优化"}},[v._v("#")]),v._v(" 性能优化")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("对于CSS:")]),v._v(" "),t("blockquote",[t("p",[v._v("优化选择器路径：健全的css选择器固然是能让开发看起来更清晰，然后对于css的解析来说却是个很大的性能问题，因此相比于 .a .b .c{} ，更倾向于大家写.c{}。")]),v._v(" "),t("p",[v._v("压缩文件：尽可能的压缩你的css文件大小，减少资源下载的负担。")]),v._v(" "),t("p",[v._v("选择器合并：把有共同的属性内容的一系列选择器组合到一起，能压缩空间和资源开销")]),v._v(" "),t("p",[v._v("精准样式：尽可能减少不必要的属性设置，比如你只要设置{padding-left:10px}的值,那就避免{padding:0 0 0 10px}这样的写法")]),v._v(" "),t("p",[v._v("雪碧图：在合理的地方把一些小的图标合并到一张图中，这样所有的图片只需要一次请求，然后通过定位的方式获取相应的图标，这样能避免一个图标一次请求的资源浪费。")]),v._v(" "),t("p",[v._v("避免通配符：.a .b "),t("em",[v._v("{} 像这样的选择器，根据从右到左的解析顺序在解析过程中遇到通配符（")]),v._v("）回去遍历整个dom的，这样性能问题就大大的了。")]),v._v(" "),t("p",[v._v("少用Float:Float在渲染时计算量比较大，尽量减少使用。")]),v._v(" "),t("p",[v._v("0值去单位：对于为0的值，尽量不要加单位，增加兼容性")])])]),v._v(" "),t("li",[t("p",[v._v("对于JavaScript：")]),v._v(" "),t("blockquote",[t("p",[v._v("尽可能把script标签放到body之后，避免页面需要等待js执行完成之后dom才能继续执行，最大程度保证页面尽快的展示出来。")]),v._v(" "),t("p",[v._v("尽可能合并script代码，")]),v._v(" "),t("p",[v._v("css能干的事情，尽量不要用JavaScript来干。毕竟JavaScript的解析执行过于直接和粗暴，而css效率更高。")]),v._v(" "),t("p",[v._v("尽可能压缩的js文件，减少资源下载的负担")]),v._v(" "),t("p",[v._v("尽可能避免在js中逐条操作dom样式，尽可能预定义好css样式，然后通过改变样式名来修改dom样式，这样集中式的操作能减少reflow或repaint的次数。")]),v._v(" "),t("p",[v._v("尽可能少的在js中创建dom，而是预先埋到HTML中用display:none来隐藏，在js中按需调用，减少js对dom的暴力操作。")])])]),v._v(" "),t("li",[t("p",[v._v("对于HTML：")]),v._v(" "),t("blockquote",[t("p",[v._v("避免在HTML中直接写css代码。")]),v._v(" "),t("p",[v._v("使用Viewport加速页面的渲染。")]),v._v(" "),t("p",[v._v("使用语义化标签，减少css的代码，增加可读性和SEO。")]),v._v(" "),t("p",[v._v("减少标签的使用，dom解析是一个大量遍历的过程，减少无必要的标签，能降低遍历的次数。")]),v._v(" "),t("p",[v._v("避免src、href等的值为空。")]),v._v(" "),t("p",[v._v("减少dns查询的次数。避免再HTML中直接写css代码。")]),v._v(" "),t("p",[v._v("使用Viewport加速页面的渲染。")]),v._v(" "),t("p",[v._v("使用语义化标签，减少css的代码，增加可读性和SEO。")]),v._v(" "),t("p",[v._v("减少标签的使用，dom解析是一个大量遍历的过程，减少无必要的标签，能降低遍历的次数。")]),v._v(" "),t("p",[v._v("避免src、href等的值为空。")]),v._v(" "),t("p",[v._v("减少dns查询的次数。")])])])]),v._v(" "),t("blockquote",[t("p",[v._v("参考！！！"),t("a",{attrs:{href:"https://juejin.cn/post/6844903687593148429",target:"_blank",rel:"noopener noreferrer"}},[v._v("假不理，掘金"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);_.default=e.exports}}]);